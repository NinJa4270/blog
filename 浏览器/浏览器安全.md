## 浏览器安全

### 同源策略
1. 隔离`dom`,数据(`Cookie/Storage/IndexDB`)，网络层。


### XSS攻击 跨站脚本攻击

1.  如何注入的
    1.  存储型`XSS`（Web 服务器）
        1.  将恶意代码存放到有漏洞服务器数据库中
    2.  反射型`XSS`（Web 服务器）
        1.  恶意 `js` 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 `js` 脚本返回给用户
    3.  基于`DOM`的`XSS` （浏览器）
        1.  通过网络劫持（ `WIFI,本地恶意软件`），在传输过程中修改HTML内容

2.  预防
    1.  服务器对输入脚本进行过滤或转码
    2.  充分利用 `CSP` (让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器能否执行内联JS代码。)
    3.  使用 `HttpOnly`保护 `Cookie`安全 (只能用在HTTP请求中，无法通过js脚本获取)


### CSRF攻击 跨站请求伪造
1.  诱用户打开网站，在网站中，利用用户的登录状态发起的跨站请求。
    1.  自动发起`get`请求
    2.  自动发起`post`请求
    3.  引诱用户点击链接
2.  预防
    1.  利用好 `Cookie`的 `SameSite`
    2.  验证请求的来源站点 `Referer` `Origin`
    3.  `CSRF Token`


### HTTPS 在http和tcp中加入 安全层
1.  对称加密（加密和解密都使用的是相同的密钥）
    1.  安全性较低
2.  使用非对称加密 （非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。） 服务器将明文形式发送给浏览器的叫 公钥 留在服务器的是 私钥
    1.  非对称加密的效率太低
    2.  法保证服务器发送给浏览器的数据安全
3.  对称加密和非对称加密搭配使用
4.  添加数字证书


### HTTP HTTPS区别
**HTTP**
-   支持客户/服务器模式
-   简单快速 请求方法和路径
-   灵活 任意类型数据 Content-Type标记
-   无连接 每次连接只处理一次 收到应答后就断开连接
-   无状态 HTTP协议无法根据上次请求进行本次请求的处理

**HTTPS**
-   过程
    -   客户端通过URL访问服务器建立SSL连接
    -   服务器接收到请求后，将网站支持的证书信息（包含公钥）传递给客户端
    -   客户端协商SSL连接的安全等级
    -   浏览器根据双方同意的安全等级，建立会话密钥，然后用公钥对会话密钥进行加密，传给服务器
    -   服务器利用自己的私钥解密
**区别**
-   HTTPS更加安全
-   默认端口80/443
-   HTTPS需要加密和多次握手，性能不如HTTP
-   HTTPS需要SSL证书